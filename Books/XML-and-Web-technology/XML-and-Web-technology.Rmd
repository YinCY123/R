---
title: "XML-and-Web-technology"
author: "yincy"
date: "7/2/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE, warning=FALSE}
library(XML)
library(rjson)
library(tidyverse)
```


# Chapter 1 Getting Started with XML and JSON  
## Reading from HTMLTables  
```{r}
u <- "/home/yincy/git/R-codes/Books/XML-and-Web-technology/files/List of countries and dependencies by population - Wikipedia.html"
tbls <- readHTMLTable(doc = u)
tbls %>% class()
```

```{r}
sapply(tbls, names)
sapply(tbls, nrow) # the large table is the population table
```

```{r}
pop <- readHTMLTable(doc = u, 
                     which = 1, 
                     header = T)
colnames(pop) <- c("Rank", "Country", "Population", "Percentage", "Date", "Source")
pop %>% head()
```


For each <table> node, `readHTMLTable()` loops over the row nodes (<tr>) and processes each cell in the row. These cells are either <th> or <td> elements for header or regular data, respectively.  

The data are typically in <td> elements, and we simply extract the contents of each cell as string.  

The <th> elements in a table typically indicate column header, and is used for variable names when appropriate.  


# Chapter 3 Parsing XML Content  
```{r}
doc <- xmlParse("Data/Kiva/lenders/")
lenderNode <- xmlRoot(doc)[["lenders"]]
occ <- sapply(xmlChildren(lenderNode), function(node) {
    xmlValue(node[["occupation"]])
}) %>% table() %>% sort(decreasing = T)
```


```{r}
doc <- xmlParse(file = "Data/merged_catalog.xml.gz")
root <- xmlRoot(x = doc)
xmlName(root)
```

```{r}
root %>% xmlSize()
```

```{r}
xmlChildren(root) %>% length()
```

```{r}
event1 <- root[["event"]]
event1
```

```{r}
event1[[10]] %>% xmlAttrs() %>% .["value"]
```

```{r}
root[1:3]
```

```{r}
evs <- root["event"]
length(evs)
root[names(root) == "event"]
```


```{r}
names(event1) # node names of the child elements
```

```{r}
xmlName(event1) # node names of the node itself
``` 

```{r}
doc <- xmlParse(file = "Data/Kiva/lenders/1.xml")
lenderNode <- xmlRoot(doc)[["lenders"]]
xmlSize(lenderNode)
```

```{r}
lenderNode
lenderNode[[1]][c("name", "occupation", "image", "country_code")]
```

```{r}
lenderNode[[1]][c("name", "image", "whereabouts", "country_code")]
```

```{r}
w <- sapply(xmlChildren(lenderNode[[1]]), xmlSize) > 1
lenderNode[[1]][w]
```


```{r}
doc <- xmlParse(file = "Data/merged_catalog.xml.gz")
root <- xmlRoot(x = doc)

timests <- xmlSApply(X = root, xmlGetAttr, name = "time-stamp")
timests %>% class()
timests[[1]]
```

```{r}
xmlSApply(X = root, xmlGetAttr, name = "id")
```

```{r}
child10 <- xmlSApply(root, "[[", 10) %>% sapply(X = ., xmlGetAttr, name = "value")
names(child10) <- NULL
table(child10) %>% barplot()
```

```{r}
xmlSApply(root, xmlSize)[1:4]
```

more general approch to ge magnitude  
```{r}
mags <- xmlSApply(root, function(evNode){
    parNames = xmlSApply(evNode, xmlGetAttr, "name")
    i = which(parNames == "magnitude")
    xmlGetAttr(evNode[[i]], name = "value")
})
```

```{r}
mags <- getNodeSet(doc = root, 
           path = "/merge/event/param[@name='magnitude']/@value") %>% 
    unlist() %>% 
    as.numeric()
mags %>% table() %>% barplot()
```


```{r}
# do not lost access to the parent even though we assigned this node to a new variable.  
firstMag <- root[[1]][[10]]

getSibling(node = firstMag, after = T)
```


```{r}
xmlParent(firstMag) %>% getSibling(after = TRUE) %>% xmlAttrs()
```


```{r}
xmlAncestors(x = firstMag)[[1]] %>% xmlName()
```

```{r}
firstMag %>% xmlParent() %>% getSibling(after = T) %>% .[[10]]
```

```{r}
root[2]
```


**The DOM Parser in R**  

read the XML document into R  
```{r}
doc <- xmlParse(file = "Data/sampleDoc.xml")
```

Access the root node  
```{r}
root <- xmlRoot(x = doc)
```

Operate on a node as if it is a list of its children, i.e. use `[` and `[[` to access elements in the tree.  
```{r}
node3_1 <- root[[3]][[1]]
node3_1 <- root[["section"]][["para"]]
```

The `XML` package provides functions for determining information about a node. These include `xmlName()`, `xmlSize()`, `xmlAttrs()`, `xmlGetAttr()`, `xmlValue`, `xmlNamespace()` and `getDefaultNamespace()`, which provide, in order, the node's name, number of children, attributes, a specific attribute, text content of the node and its descendants, namespace, and defualt namespace.  
```{r}
root[["title"]] %>% xmlValue()
root[["section"]] %>% xmlValue()
```

In addition to `[` and `[[`, other functions in XML enables us to work with a node's aiblings, children, parent and acncestors. These are `getSibling()`, `xmlChildren()`, `xmlParent()`, and `xmlAncestors()`, respectively.  
```{r}
node3_1 %>% xmlParent()
```

```{r}
getSibling(node = root[[2]])
```

```{r}
node3_1 %>% xmlParent() %>% xmlParent() %>% .[[1]]

# equal to the root[[1]]
root[[1]]
```

```{r}
node3_1 %>% xmlParent() %>% getSibling(after = F) %>% getSibling(after = F)
```

The tree object behaves differently from regular R objects. When we make the assignment, `node3_1 == root[[3]][[1]]`, we now have a reference to that point in the tree. Any operations on `node3_1` will be made to the tree as well.  
```{r}
node3_1 = root[[3]][[1]]
node3_1 %>% xmlParent() %>% xmlParent()
```


## Parsing Other XML Element Types  
```{r}
rdbRoot <- xmlParse(file = "Data/sampleDoc.xml") %>% xmlRoot()

rdbRoot[[2]]
```

```{r}
rdbRoot[[2]] %>% xmlValue()
```

The `xmlValue()` function is generic so it it works on different types of nodes. For nodes that are mixtures of text content and other nodes, `xmlValue()` returns a character string that concatenates the text content of all the node's descendants.  
```{r}
rdbRoot[[3]][[1]] %>% names()
```

```{r}
rdbRoot[[3]][[1]] %>% 
    xmlChildren() %>% 
    sapply(class)
```

```{r}
rdbRoot[[3]][[1]] %>% 
    xmlSApply(xmlValue)
```

```{r}
rdbRoot[[3]][[1]] %>% 
    xmlNamespace()


rdbRoot[[3]][[1]] %>% 
    getDefaultNamespace()
```


## Reading XML from Different Input Sources  
The parser available through the `XML` package supports reading local files, in-memory XML strings, URLs, and 'local' compressed files.  
```{r}
xmlParse(file = "https://sports.sohu.com/s/nba", isHTML = T)
```

 
```{r}
getEncoding(obj = rdbRoot)
```


# Chapter 4 XPath, XPointer, and XInclude  
```{r}
doc <- htmlParse(file = "http://www.bioconductor.org/packages/release/bioc/vignettes/TCGAbiolinks/inst/doc/subtypes.html")
listOfNodes <- getNodeSet(doc = doc, path = "//a[@href]")
```

```{r}
xpathSApply(doc, path = "//a[@href]", fun = xmlGetAttr, name = "href") %>% head()
```

```{r}
getNodeSet(doc, path = "//a/@href") %>% .[10:20]
```


```{r}
mil <- xmlParse(file = "files/sweat_metabolites.xml")

mol <- getNodeSet(doc = mil, path = "/*/metabolite/accession/text()")
xpexpr <- ".//metabolite/accession/text()"
lapply(mil, function(node) xpathSApply(node, xpexpr, xmlValue))
```


## XPath and the XML Tree  
```{r}
doc <- xmlParse(file = "Data/eurofxref-hist.xml")
root <- xmlRoot(x = doc)
root %>% xmlSize()
```

```{r}
xpexpr <- "/Envelope/Sender/name"
nm <- getNodeSet(doc = root, path = xpexpr)
nm %>% xmlToDataFrame()
```

```{r}
mn <- getNodeSet(doc = root, path = "//Cube[@currency = 'JPY']")
mn %>% xmlToDataFrame()
```

```{r}
getNodeSet(doc = doc, path = "//Cube[@currency = 'CZK' and @rate < 25]")
```


## XPath Syntax  

































