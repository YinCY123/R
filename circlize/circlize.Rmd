---
title: "circlize"
author: "yincy"
date: "4/27/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE, warning=FALSE}
library(circlize)
```

# Chapter 1 Introduction  
Circular layout is very useful to represent complicated information. First, it elegantly represents information with long axes or a large amount of categories; second, it intuitively shows data with multiple tracks focusing on the same object; third, it easily demonstrates relations between elements. It provides an efficient way to arrange information on the circle and it is beautiful.  

Circos is a pioneer tool widely used for circular layout representations implemented in Perl. It greatly enhances the visualization of scientific results (especially in Genomics field). Thus, plots with circular layout are normally named as “circos plot”. Here the circlize package aims to implement Circos in R. One important advantage for the implementation in R is that R is an ideal environment which provides seamless connection between data analysis and data visualization. circlize is not a front-end wrapper to generate configuration files for Circos, while completely coded in R style by using R’s elegant statistical and graphic engine. We aim to keep the flexibility and configurability of Circos, but also make the package more straightforward to use and enhance it to support more types of graphics.  

In this book, chapters in Part I give detailed overviews of the general circlize functionalities. Part II introduces functions specifically designed for visualizing genomic datasets. Part III gives comprehensive guilds on visualizing relationships by Chord diagram.  

## Principle of design  
**A circular layout is composed of sectors and tracks**. For data in different categories, they are allocated into different sectors and for multiple measurements of the same category, they are represented as stacked tracks from outside of the circle to the inside. **The intersection of a sector and a track is called a cell (or a grid, a panel), which is the basic unit in a circular layout**. It is an imaginary plotting region for data points in a certain category.  

Since most of the figures are composed of simple graphics, such as points, lines, polygon, circlize implements low-level graphic functions for adding graphics in the circular plotting regions, so that more complicated graphics can be easily generated by different combinations of low-level graphic functions. This principle ensures the generality that types of high-level graphics are not restricted by the software itself and high-level packages focusing on specific interests can be built on it.  

Currently there are following low-level graphic functions that can be used for adding graphics. The usage is very similar to the functions without `circos`. prefix from the base graphic engine, except there are some enhancement specifically designed for circular visualization.  

+ `circos.points()`: adds points in a cell.  
+ `circos.lines()`: adds lines in a cell.  
+ `circos.segments()`: adds segments in a cell.  
+ `circos.rect()`: adds rectangles in a cell.  
+ `circos.polygon()`: adds polygons in a cell.  
+ `circos.text`: adds text in a cell.  
+ `circos.axis()` ands `circos.yaxis()`: add axis in a cell.  

Following functions arrange the circular layout  

+ `circos.initialize()`: allocates sectors on the circle.  
+ `circos.track()`: create plotting regions for cells in one single track.  
+ `circos.update()`: updates an existed cell.  
+ `circos.par()`: graphic parameters.  
+ `circos.clear()`: resets graphic parameters and internal variables.  

Thus, theoretically, you are able to draw most kinds of circular figures by the above functionalities. 

## A quick glance  
```{r}
set.seed(999)

n = 1000
df <- data.frame(
    factors = sample(letters[1:8], n , replace = T), 
    x = rnorm(n), 
    y = runif(n)
)
```

First we initialize the circular layout. The circle is split into sectors based on the data range on x-axes in each category. In following code, df$x is split by df$factors and the width of sectors are automatically calculated based on data ranges in each category. Be default, sectors are positioned started from  θ = 0 (in the polar coordinate system) and go along the circle clock-wisely. You may not see anything after running following code because no track has been added yet.  

We set a global parameter track.height to 0.1 by the option function `circis.par()` so that all tracks which will be added have a default height of 0.1. The circle used by circlize always has a radius of 1, so a height of 0.1 means 10% of the circle radius.  

**Note that the allocation of sectors only needs values on x direction (or on the circular direction), the values on y direction (radical direction) will be used in the step of creating tracks**.  

After the circular layout is initialized, graphics can be added to the plot in a track-by-track manner. Before drawing anything, we need to know that all tracks should be first created by `circos.trackPlotRegion()` or, for short, `circos.track()`, then the low-level functions can be added afterwards. Just think in the base R graphic engine, you need first call `plot()` then you can use functions such as `points()` and `lines()` to add graphics. Since x ranges for cells in the track have already been defined in the initialization step, here we only need to specify the y ranges for each cell. The y ranges can be specified by y argument as a numeric vector (so that y ranges will be automatically extracted and calculated in each cell) or ylim argument as a vector of length two. In principle, y ranges should be same for all cells in a same track.  
```{r, message=FALSE, warning=FALSE}
library(circlize)

circos.par("track.height" = 0.1)
circos.initialize(factors = df$factors, x = df$x)

# first track 
circos.track(factors = df$factors, y = df$y, 
             panel.fun = function(x, y){
                 circos.text(x = CELL_META$xcenter, 
                             y = CELL_META$cell.ylim[2] + uy(5, "mm"), 
                             labels = CELL_META$sector.index)
                 circos.axis(labels.cex = 0.6)
             })

col <- rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(df$factors, df$x, df$y, col = col, pch = 16, cex = 0.5)
circos.text(x = -1, y = 0.5, label = "text", sector.index = "a", track.index = 1)

# second track
bgcol <- rep(c("#EFEFEF", "#CCCCCC"), 4)
circos.trackHist(factors = df$factors, x = df$x, bin.size = 0.2, bg.col = bgcol, col = NA)

# third track 
circos.track(factors = df$factors, x = df$x, y = df$y, 
             panel.fun = function(x, y){
               ind = sample(length(x), 10)
               x2 = x[ind]
               y2 = y[ind]
               od = order(x2)
               circos.lines(x2[od], y2[od])
             })

# update cell 'd' in second track 
circos.update(sector.index = "d", track.index = 2, bg.col = "#FF8080", bg.border = "black")
circos.points(x = -2.2, y = rep(0.5, 5), col = "white")
circos.text(x = CELL_META$xcenter, y = CELL_META$ycenter, labels = 'updated', col = "white")

# fourth track, heatmap 
circos.track(ylim = c(0, 1), panel.fun = function(x, y){
  xlim = CELL_META$xlim
  ylim = CELL_META$ylim
  breaks = seq(xlim[1], xlim[2], by = 0.1)
  n_breaks = length(breaks)
  circos.rect(xleft = breaks[-n_breaks], ybottom = rep(ylim[1], n_breaks - 1), 
              breaks[-1], rep(ylim[2], n_breaks -1), 
              col = rand_color(n_breaks), border = NA)
})

# fith track, links  
circos.link(sector.index1 = "a", point1 = 0, sector.index2 = "b", point2 = 0, h = 0.4)
circos.link(sector.index1 = "c", point1 = c(-0.5, 0.5), sector.index2 = "d", point2 = c(-0.5, 0.5), col = "red", 
            border = "blue", h = 0.2)
circos.link(sector.index1 = "e", point1 = 0, sector.index2 ="g", point2 = c(-1, 1), col = "green", border = "black", lwd = 2, lty  =2)

# reset the graphic parameters and internal variables, so that it will not mess up your next plot 
circos.clear()
```


# Chapter 2 Circular layout  
## Coordinate transformation  
o map graphics onto the circle, there exist transformations from several coordinate systems. First, there are data coordinate systems in which ranges for x-axes and y-axes are the ranges of original data. Second, there is a polar coordinate system in which these coordinates are mapped onto a circle. Finally, there is a canvas coordinate system in which graphics are really drawn on the graphical device.  

Each cell has its own data coordinate and they are independent. `circlize` first transforms coordinates from data coordinate system to polar coordinate system and finally transforms into canvas coordinate system.   

For users, they only need to imagine that each cell is a normal rectangular plotting region (data coordinate) in which x-lim and y-lim are ranges of data in that cell. `circlize` knows which cell you are in and does all the transformations automatically.  

The final canvas coordinate is in fact an ordinary coordinate in the base R graphic system with x range in (-1, 1) and y range in (-1, 1) by default. It should be noted that **the circular plot is always drawn inside the circle which has radius of 1 (which means it is always a unit circle), and from outside to inside**.   

## Rules for making the circular plot  
The rule for making the circular plot is rather simple. It follows the sequence of `initialize layout -> create track -> add graphics -> create track -> add graphics - ... -> clear`. Graphics can be added at any time as long as the tracks are created.  

1. Initialize the layout using `circos.initialize()`. Since circular layout in fact visualizs data which is in categories, there must be at least a categorial variable. Ranges of x values on each category can be specified as a vector or the range itself.  

2. Create plotting regions for the new track and add graphics. The new track is created just inside the previously created one. Only after the creation of the track can you add other graphics on it. There are three ways to add graphics in cells.  

+ After the creation of the track, use low-level graphic function like `circos.points()`, `circos.lines()`, … to add graphics cell by cell. It always involves a for loop and you need to subset the data by the categorical variable manually.  

+ Use `circos.trackPoints()`, `circos.trackLines()`, … to add simple graphics through all cells simultaneously.  

+ Use `panel.fun` argument in `circos.track()` to add graphics immediately after the creation of a certain cell. `panel.fun` needs two arguments `x` and `y` which are `x` values and `y` values that are in the current cell. This subset operation is applied automatically. This is the most recommended way. Section 2.7 gives detailed explanation of using panel.fun argument.  

+ Repeat step 2 to add more tracks on the circle unless it reaches the center of the circle.  

+ Call circos.clear() to clean up.  

As mentioned above, there are three ways to add graphics on a track.  

1. Create plotting regions for the whole track first and then add graphics by specifying `sector.index`. In the following pseudo code, `x1`, `y1` are data points in a given cell, which means you need to do data subsetting manually.  

In following code, circos.points() and circos.lines() are used separatedly from circos.track(), thus, the index for the sector needs to be explicitly specified by sector.index argument.  

There is also a `track.index` argument for both functions, however, the default value is the “current” track index and as the two functions are used just after `circos.track()`, the “current” track index is what the two functions expect and it can be ommited when calling the two functions.  

```
circos.initialize(factors = factors, x = xlim)
circos.track(factors, ylim)
for(sector.index in all.sector.index){
  circos.points(x1, y1, sector.index)
  circos.lines(x2, y2, sector.index)
}
```

2. Add graphics in a batch mode. In following code, `circos.trackPoints()` and `circos.trackLines()` need a categorical variable, a vector of x values and a vector of y values. X and y values will be split by the categorical variable and sent to corresponding cell to add the graphics. Internally, this is done by using `circos.points()` or `circos.lines()` in a for loop. This way to add graphics would be convenient if users only want to add a specific type of simple graphics (e.g. only points) to the track, but it is not recommended for making complex graphics.  

`circos.trackPoints()` and `circos.trackLines()` need a `track.index` to specify which track to add the graphics. Similarly, since these two are called just after `circos.track()`, the graphics are added in the newly created track right away.  
```
circos.initialize(factors, xlim)
circos.track(factors, ylim)
circos.trackPoints(factors, x, y)
circos.trackLines(factors, x, y)
```

3. Use a panel function to add self-defined graphics as soon as the cell has been created. This is the way recommended and you can find most of the code in this book uses `panel.fun`. `circos.track()` creates cells one by one and after the creation of a cell, and `panel.fun` is executed on this cell immediately. In this case, the “current” sector and “current” track are marked to this cell that you can directly use low-level functions without specifying sector index and track index.  

If you look at following code, you will find the code inside `panel.fun` is as natural as using `points()` or `lines()` in the normal R graphic system. This is a way to help you think a cell is an “imaginary rectangular plotting region”.  

```
circos.initialize(factors, xlim)
circos.track(factors, all_x, all_y, ylim, 
             panel.fun = function(x, y){
               circos.points(x, y)
               circos.lines(x, y)
             })
```

There are several internal variables keeping tracing of the current sector and track when applying `circos.track()` and `circos.update()`. Thus, although functions like `circos.points()`, `circos.lines()` need to specify the index of sector and track, they will take the current one by default. As a result, if you draw points, lines, text et al just after the creation of the track or cell, you do not need to set the sector index and the track index explicitly and it will be added in the most recently created or updated cell.  


## Sectors and tracks  
A circular layout is composed of sectors and tracks. As illustrated in Figure 2.3, the red circle is one track and the blue represents one sector. The intersection of a sector and a track is called a cell which can be thought as an imaginary plotting region for data points. In this section, we introduce how to set data ranges on x and y directions in cells.  
```{r, fig.align='center'}
knitr::include_graphics(path = "/home/yincy/git/R-codes/circlize/figures/Sectors-and-tracks.png")
```

Sectors are first allocated on the circle by `circos.initialize()`. There must be a categorical variable (say `factors`) that on the circle, each sector corresponds to one category. The width of sectors (measured by degree) are proportional to the data range in sectors on `x` direction (or the circular direction). The data range can be specified as a numeric vector `x` which has same length as `factors`, then `x` is split by `factors` and data ranges are calculated for each sector internally.   

Data ranges can also be specified directly by `xlim` argument. The valid value for `xilm` is a two-column matrix with same number of rows as number of sectors that each row in `xlim` corresponds to one sector. If `xlim` has row names which already cover sector names, row order of `xlim` is automatically adjusted. If `xlim` is a vector of length two, all sectors have the same `x` range.  
```
circos.initialize(factors, x = x)
circos.initialize(factors, xlim = xlim)
```

After the initialization of the layout, you may not see anything drawn or only an empty graphical device is opened. That is because no track has been created yet, however, the layout has already been recorded internally.  

In the initialization step, not only the width of each sector is assigned, but also the order of sectors on the circle is determined. **Order of the sectors are determined by the order of levels of the input factor**. If the value for `factors` is not a factor, the order of sectors is `unique(factors)`. Thus, if you want to change the order of sectors, you can just change of the level of `factors` variable. The following code generates plots with different sector orders.  
```
fa <- c('d', 'f', 'e', 'c', 'g', 'b', 'a')
f1 <- factor(fa)
circos.initialize(factors = f1, xlim = c(0, 1))
f2 <- factor(fa, levels = fa)
circos.initialize(factors = f2, xlim = c(0, 1))
```
```{r, fig.align='center'}
knitr::include_graphics("/home/yincy/git/R-codes/circlize/figures/sector-orders.png")
```

**In different tracks, cells in the same sector share the same data range on x-axes**. Then, for each track, we only need to specify the data range on y direction (or the radical direction) for cells. Similar as `circos.initialize()`, `circos.track()` also receives either `y` or `ylim` argument to specify the range of y-values. Since all cells in a same track shares a same `y` range, `ylim` is just a vector of length two if it is specified.  

`x` can also be specified in `circos.track()`, but it is only used to send to panel.fun. In Section 2.7, we will introduce how `x` and `y` are sent to each cell and how the graphics are added.  

```
circos.track(factors, y = y)
circos.track(factors, ylim = c(0, 1))
circos.track(factors, x = x, y = y)
```

In the track creation step, since all sectors have already been allocated in the circle, if `factors` argument is not set, `circos.track()` would create plotting regions for all available sectors. Also, levels of `factors` do not need to be specified explicitly because the order of sectors has already be determined in the initialization step. If users only create cells for a subset of sectors in the track (not all sectors), in fact, cells in remaining unspecified sectors are created as well, but with no borders (pretending they are not created).  

```
# assume 'factors' only covers a subset of sector  
# You will only see cells that are covered in 'factors' have borders  

circos.track(factors, y = y)

# You will see all cells have borders
circos.track(ylim = ranges(y))
```

Cells are basic units in the circular plot and are independent from each other. After the creation of cells, they have self-contained meta values of x-lim and y-lim (data range measured in data coordinate). So if you are adding graphics in one cell, you do not need to consider things outside the cell and also you do not need to consider you are in the circle. Just pretending it is normal rectangle region with its own coordinate.  

```{r, fig.align='center'}
knitr::include_graphics("/home/yincy/git/R-codes/circlize/figures/Sector-directions.png")
```

## Graphic parameters  


















