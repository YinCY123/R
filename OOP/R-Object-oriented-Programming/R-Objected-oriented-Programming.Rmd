---
title: "R-Objected-oriented-Programming"
author: "yincy"
date: "2/24/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Chapter 1 Data Types  
The `<-` operator for the assignment will work in any context while the `=` operator only works for complete expressions.  

Another option is to use the `<<-` operator. The advantage of the `<<-` operator is that it instructs the R environment to search parent environments to see whether the variable already exists. In some contexts, within a function for example, the `<-` operator will create a new variable; however, **the `<<-` operator will make use of an existing variable outside of the function if it is found**.   


reverse assignment: -> or ->>  

The `save` and `save.image` commands can be used to save the current workspace.  

The `save` command allows you to save a particular variable, and the `save.image` command allows you to save the entire workspace.  

You can save your history using the `savehistory` command, The history can be displayed using the `histry` command, and the ``loadhistory` command can be used to replay the commands in a file.  

Note that there are two ways to access an element in the vector: **single versus double braces**. For a vector, the two methods are nearly the same, but when we explore the use of lists as opposed to vectors, the meaning will change. In short, the double braces return objects of the same type as the elements within the vector, and the single braces return values of the same type as the variable itself.  


The `typeof` command indicates how R stores the object and is different from the class command, which is an attribute that you can change or query.  

A single `&` is used to perform an and operation on each pairwise element of two vectors, while the double `&&` returns a single logical result using only the first elements of the vectors.  


## Chapter 2 Organizing Data  
**apply**  
```{r}
A <- matrix(1:12, nrow = 3, byrow = T)
A
```

```{r}
apply(A, 1, sum)
```

```{r}
apply(A, 2, sum)
```


**lapply** and **sapply**  
```{r}
theList <- list(one = c(1, 2, 3), two  =c(T, F, T, T))
sumList <- lapply(theList, sum)
sumList
```

```{r}
typeof(sumList)
```

```{r}
meanResult <- sapply(X = theList, FUN = mean)
meanResult
```

```{r}
typeof(meanResult)
```


**tapply**  
```{r}
diameters <- c(28.8, 27.3, 45.8, 34.8, 25.3)
three <- as.factor(c('pine', 'pine', 'oak', 'pine', 'oak'))
tapply(X = diameters, INDEX = three, FUN = sd)
```

**mapply**  
The `mapply` command takes a function to apply and a list of arrays. The function takes the first elements of each array and applies the function to that list. It then takes the second elements of each array and applies the function. This is repeated until it goes through every element.  
```{r}
a <- c(1, 2, 3)
b <- c(1, 2, 3)
mapply(FUN = sum, a, b)
```


## Chapter 3 Saving Data and Printing Results  
```{r}
dir(path = "../../", pattern = "r", full.names = T)
```

```{r}
list.files(path = "../../", pattern = 'r')
```

```{r}
list.dirs(path = "../../", full.names = T, recursive = F)
```


```{r}
x <- scan(file = 'data/diameter.csv')
x
```

```{r}
x <- scan(file = 'data/trees.csv', what = list('character', 'double'), sep = ',')
x
```

```{r}
three <- exp(1)
nice <- format(x = three, digits = 2)
nice
```

```{r}
nice <- format(x = three, digits = 3, width = 5, justify = 'right')
nice
```

```{r}
nice <- format(x = three, digits = 3, justify = "right", decimal.mark = "#")
nice
```

```{r}
fileConnector <- file(description = "data/twoBinaryValues.dat", open = 'wb')
theNumber <- as.double(x = 2.72)
writeBin(object = theNumber, con = fileConnector, size = 4)

note <- "hello three!"
nchar(note)
writeBin(object = note, con = fileConnector, size = nchar(note))
close(fileConnector)
```


```{r}
fileConnector <- file(description = "data/twoBinaryValues.dat", open = 'rb')

value <- readBin(con = fileConnector, what = double(), n = 1, size = 4)
value
note <- readBin(con = fileConnector, what = character(), n = 12, size = 1)
note
close(fileConnector)
```


## Chapter 4 Calculating Probabilities and Random Numbers  
distribution prefix:  

- `d`: This determines the value of the distribution function, for example, dnorm is the height of the normal's probability distribution function.  

- `p`: This determines the cumulative distribution, for example, pnorm is the cumulative distribution function for the normal distribution.  

- `q`: This determines the inverse cumulative distribution, for example, qnorm is the inverse cumulative distribution function for the normal distribution.  

- `r`: This generates random numbers according to the distribution, for example, rnorm calculates random numbers that follow a normal distribution.  


The distribution   


Discrete         |                |  Continuous  |
-----------------|----------------|--------------|-----------------
Name             | Suffix         | Name         | Suffix
-----------------|----------------|--------------|-----------------
Beta             | beta           | X^2          | chisq
Binomial         | binom          | Exponential  | exp
Cauchy           | cauchy         | F            | f
Geometric        | geom           | Gamma        | gamma
Hypergeometric   | hyper          | Log Normal   | lnorm
Multinomial      | mutlinom       | Normal       | norm
Negative Binomail| nbinom         | Student t    | t
Poisson          | pois           | Uniform      | unif
                 |                | Weibull      | weibull


```{r}
x <- 1:100
probabilities <- dpois(x = x, lambda = 50.0)
barplot(height = probabilities, names.arg = x,  
        xlab = 'x', ylab = "p", 
        main = "Poission Distribution, lambda = 50.0",
        density = 5,
        angle = 135,
        col = 'grey')
```


```{r}
x <- seq(0.0, 100, 0.1)
prob <- dchisq(x = x, df = 30)
plot(x = x, 
     y = prob, 
     main = "Chi Squared Distribution",
     xlab = "x",
     ylab = "p",
     col = 2, 
     type = 'l')

probTwo <- dchisq(x = x, df = 35)
points(x = x, y = probTwo, 
       col = 3,
       type = 'l')

abline(v = c(30, 35) - 2, lty = 2, col = "blue")
```


```{r}
x <- seq(0, 20, by = 1)
cdf <- ppois(q = x, lambda = 10.0)
barplot(cdf, names.arg = "", 
        border = "grey", 
        col = "grey",
        ylim = c(0, 1))
```


```{r}
x <- seq(-5, 5, 0.01)
cdf <- pnorm(q = x)
plot(x, cdf, type = "l", col = "blue")
points(x = x[401:600], y = cdf[401:600], type = "h", col = "red")
abline(v = 0)
```

```{r}
x <- seq(0, 100.0, by = 0.1)
cdf <- pchisq(q = x, df = 30)

plot(x = x, y = cdf, 
     main = "Chi Squared Distribution",
     xlab = "x", 
     ylab = "p",
     col = "red", 
     type = "l", 
     xlim = c(0, 100))

cdfTwo <- pchisq(q = x, df = 35)
points(x = x, y = cdfTwo, col = "blue", type = "l")

legend("topleft", legend = c("df = 30", "df = 35"), 
       lty = 1, 
       col = c("red", "blue"),
       bty = "n")

points(x = seq(0, qchisq(p = 0.3, df = 30), 0.01), 
       y = pchisq(q = seq(0, qchisq(p = 0.3, df = 30), 0.01), df = 30), 
       type = "h", 
       col = "red")

points(x = seq(0, qchisq(p = 0.3, df = 35), 0.01), 
       y = pchisq(q = seq(0, qchisq(p = 0.3, df = 35), 0.01), df = 35), 
       type = "h", 
       col = "blue")
```


```{r}
a <- qchisq(p = 0.5, df = 30)
a
```



```{r}
numbers <- rpois(n = 100, lambda = 10.0)
hist(numbers, 
     main = "100 Samples of a Poisson Distribution", 
     xlab = "x")
```


```{r}
numbers <- rchisq(n = 100, df = 30)
hist(numbers, 
     main = "100 Samples from a Chi-Squared Distribution", 
     xlab = "x")
```


```{r}
sample(3)
```

```{r}
sample(5)
```

```{r}
sample(5.6)
```

```{r}
x <- c(1, 3, 5, 7)
sample(x)
```

```{r}
x <- c(1, 3, 5, 7)
sample(x, size = 2)
```

```{r}
sample(x, size = 3)
```

```{r}
sample(x, size = 7, replace = T)
```


```{r}
sample(x, size = 8, replace = T, prob = c(0.05, 0.1, 0.15, 0.7))
```


## Chapter 5: Character and String Operations  
```{r}
urls <- c("https://duckduckgo.com?q=Johann+Carl+Friedrich+Gauss",
          "https://search.yahoo.com/search?p=Jean+Baptiste+Joseph+Fourier", 
          "http://www.bing.com/search?q=Isaac+Newton", 
          "http://www.google.com/search?q=Brahmagupta")
```

**Six string manipulation operations**:  

- determine the length of a string  
- location of a substring  
- extract or replace a substring  
- change the case of a string  
- split a string into separate parts  
- express a comnination of objects as a single string  


```{r}
nchar(urls)
```

```{r}
nchar(c("one", NA, 1234))
```

```{r}
# nchar(as.factor(c("a","b","a","a","b","c")))
```

```{r}
nzchar(c("one", NA, 1234, ""))
```

```{r}
c("one", NA, 1234, "")[nzchar(c("one", NA, 1234, ""))]
```

```{r}
colons <- regexpr(pattern = ":", text = urls)
```


```{r}
substr(x = urls, start = 1, stop = colons - 1)
```

```{r}
colons <- regexpr(pattern = ":", text = urls)
mailto <- urls
substr(mailto, 1, colons - 1) <- c("mailto", "mailto", "mailto", "mailto")
mailto
```


```{r}
tolower(urls[1])
```


```{r}
toupper(urls[2])
```

```{r}
chartr(old = "=+", new = "# ", x = urls)
```


```{r}
splitURL <- strsplit(x = urls, split = ":")
splitURL
```


```{r}
splitURL[[1]][2]
```


```{r}
n <- 1
calculation <- 123.0
theTitle <- sprintf(fmt = "URL: %s, Count = %d", urls[n], calculation)
theTitle
```


**Regular expressions**  
```{r}
loc <- gregexpr(pattern = "=", urls)
loc
```

```{r}
mapply(c, loc)
```

```{r}
sub(pattern = "\\?.*$", replacement = "", x = urls)
```


## Chapter 6 Converting and Defining Time Variables  
### Converting strings to time data types  
```{r}
theTime <- c("08:30:00 1867-07-01","18:15:00 1864-10-27")
converted <- strptime(x = theTime, format = "%H:%M:%S %Y-%m-%d")
converted
```

```{r}
typeof(converted[[1]])
class(converted)
```

```{r}
converted[[1]] - converted[[2]]
```


```{r}
otherTime <- as.POSIXct(converted)
otherTime
otherTime %>% class()
otherTime %>% unclass()
```

```{r}
typeof(otherTime)
```

```{r}
otherTime[[1]]
```


### Converting time data types to strings  
A date and time variable can be converted to a string using the `strftime` command.  
```{r}
theTime <- c("08:30:00 1867-07-01","18:15:00 1864-10-27")
converted <- strptime(x = theTime, format = "%H:%M:%S %Y-%m-%d", tz = "Canada/Eastern")
converted
```

```{r}
typeof(converted)
```

```{r}
backagain <- strftime(x = converted, format = "%j - %B")
backagain
```

```{r}
typeof(backagain)
```


### Operations on time data types  
```{r}
earlier <- strptime("2014-01-01 00:00:00","%Y-%m-%d %H:%M:%S")
later <- strptime("2014-01-02 00:00:00","%Y-%m-%d %H:%M:%S")
later - earlier
```


```{r}
timeDiff <- later - earlier
timeDiff
```

```{r}
as.double(timeDiff)
```

```{r}
earlier + timeDiff
```

```{r}
earlier <- strptime("2014-01-01 00:00:00","%Y-%m-%d %H:%M:%S")
later <- strptime("2014-01-01 12:00:00","%Y-%m-%d %H:%M:%S")
later - earlier
```

```{r}
timeDiff <- later - earlier
timeDiff
```

```{r}
as.double(timeDiff)
```

```{r}
attributes(timeDiff)
```


```{r}
attr(timeDiff, "units")
```


```{r}
earlier <- strptime("2014-01-01 00:00:00","%Y-%m-%d %H:%M:%S")
later <- strptime("2014-01-01 12:00:00","%Y-%m-%d %H:%M:%S")

timeDiff <- later - earlier
as.numeric(timeDiff, units = "weeks")
```

```{r}
as.numeric(timeDiff, units = "mins")
```

```{r}
earlier <- strptime("2014-01-01 00:00:00","%Y-%m-%d %H:%M:%S")
later <- strptime("2014-01-01 12:00:00","%Y-%m-%d %H:%M:%S")
timeDiff <- difftime(time1 = later, time2 = earlier, units = "day")
timeDiff
```

```{r}
later <- strptime("2014-01-01 12:00:00","%Y-%m-%d %H:%M:%S")
oneHour <- as.difftime(tim = 1, units = "hours")
oneHour
```


## Chapter 7: Basic Programming
### Conditional execution  
```{r}
if(1 > 2){
        cat("One is the most biggest number\n")
} else{
        cat("One is the loneliest number\n")
}
```


```{r}
if(0){
        cat("Yes, that is FALSE.\n")
}else if(1){
        cat("Yes that is TRUE\n")
}else{
        cat("Whatever")
}
```


```{r}
x <- c(1, 2)
if(x < 2){
        cat("Oh yes it is \n")
}
```

```{r}
x <- c(FALSE,FALSE,TRUE)
y <- c(FALSE,TRUE,TRUE)
x|y
```

```{r}
x||y
```


```{r}
for(lupe in seq(1, 2, by = 0.33)){
        cat("The value of lupe is ", lupe, "\n")
}
```


```{r}
lupe <- 1.0
while(lupe <= 2.0){
        cat("The value of lupe is ", lupe, "\n")
        lupe = lupe + 0.33
}
```

The `break` and `next` statements are used to influence which part of the code in the current loop will be executed.   

The `break` statement will move to the very end of the current block and it will stop the execution of the loop.  

The `next` statement will act as if the end of the code block was reached and start over at the begining of the code block to begin the next iteration.  


```{r}
positions <- complex(0)
currentPos <- 0.0 + 0.0i
numberSteps <- 500
angle <- 0.0
stdDev <- 1.0

step <- as.integer(0)
repeat {
        step <- step + as.integer(1)
        
        if(step > numberSteps)
                break
        
        angle <- angle + rnorm(1, 0, stdDev)
        currentPos <- currentPos + exp(angle * 1.0i)
        positions <- append(positions, currentPos)
}

plot(Re(positions), Im(positions), type = "l", pch = 19, cex = 0.5)
```


```{r}
positions <- complex(0)
currentPos <- 0.0 + 0.0i
numberSteps <- 100
angleFacing <- 0.0
stdDev <- 1.0

step <- as.integer(0)
repeat{
        newAngle <- angle + rnorm(1, 0, stdDev)
        proposedStep <- currentPos + exp(newAngle * 1.0i)
        if(Re(proposedStep) < 0.0) # check if to skip this loop
                next
        
        angle <- newAngle
        currentPos <- proposedStep
        positions <- c(positions, currentPos)
        
        step <- step + as.integer(1)
        if(step > numberSteps) # check if to stop this loop
                break
}

plot(Re(positions), Im(positions), type = "l")
```


#### Functions  
```{r}
updatePosition = function(currentPos){
        newDirection <- exp(1i*runif(1, 0.0, 2.0*pi))
        currentPos + newDirection
}
updatePosition(currentPos = 0.0)
```

```{r}
updatePosition
```

One oddity associated with functions is that the value it returns is the last expression evaluated within the code block.  


```{r}
updatePosition <- function(currentPos, angle, stdDev){
        angle <- angle + rnorm(1, 0, stdDev)
        list(newPos = currentPos + exp(angle * 1.0i),
             newAngle = angle)
}

pos <- updatePosition(2.0, 0.0, 1.0)
pos
```


```{r}
updatePosition <- function(currentPos, angle, stdDev){
        angle <- angle + sample(x = seq(-1, 1, 0.01), size = 1)
        newStep <- exp(angle * 1.0i)
        if(Re(currentPos + newStep) < 0.0){
                return(list(newPos = currentPos - newPos,
                            newAngle = angle + pi))
        }
        return(list(newPos = currentPos + newStep,
                    angle = angle))
}

pos = updatePosition(currentPos = -0.1 + 2i, angle = 0, stdDev = 1)
pos
```



```{r}
updatePosition <- function(currentPos, angle, stdDev){
        angle = angle + rnorm(1, 0, stdDev)
        currentPos + exp(angle * 1i)
}

angle <- 0.0
updatePosition(currentPos = 1 + 2i, angle, 1.0)
angle # outside angle do not affected, pass value not reference
```


```{r}
updatePosition <- function(currentPos, angle = 0.0){
        print(noquote(paste("Angle is ", angle)))
        angle <- angle + runif(1, 0, 2*pi)
        currentPos + exp(1i * angle)
}

updatePosition(currentPos = 1 + 2i)
```

```{r}
updatePosition(currentPos = 1 + 2i, angle = pi)
```


```{r}
updatePosition <- function(currentPos, angle = 0){
        if(missing(angle)){
                warning("Using the default drift: ", angle, "\n\n")
        }
        angle <- angle + runif(1, 0, 2*pi)
        currentPos + exp(1i * angle)
}

updatePosition(1 + 2i)
```

```{r}
updatePosition(1+2i, pi)
```


```{r}
updatePosition <- function(currentPos, angle = 0){
        if(abs(angle) > 2.0*pi){
                stop("I arbitrarily do not like angles that big") # stop the function, and exit
        }
        angle <- angle + runif(1, 0, 2*pi)
        currentPos + exp(1i * angle)
}

pos1 <- updatePosition(1 + 2i)
pos1
```

```
pos2 <- updatePosition(1+2i, 3.0*pi)
```


```{r}
matching <- function(argOne, argTwo){
        return(paste("I got this: ", argOne, " ", argTwo))
}

matching(argTwo = "second", argOne = "First")
```


```{r}
matching(argT = "two", argO = "one") # partial matching
```

```{r}
matching(argT = "two", argO = "one") # multiple partial matching
```



```{r}
updatePosition <- function(currentPos, angle = 0, dist = c("uniform", "normal")){
        dist = match.arg(dist)
        print(dist)
        # Update position code would go below
}

updatePosition(0, 0)
```

```{r}
updatePosition(0, 0, "uniform")
```

```{r}
updatePosition(0, 0, "nor")
```


```{r}
envOne <- new.env()
typeof(envOne)
```

```{r}
ls(envOne)
```

```{r}
assign(x = "bubaa", value = 12, envir = envOne)
ls(envir = envOne)
```


```{r}
get(x = "bubaa", envir = envOne)
```


```{r}
# bubaa
```

```{r}
ls()
one <- 2
ls()
```

```{r}
envTwo <- new.env()
assign(x = "two", value = 3, envir = envTwo)
```


```{r}
attach(what = envTwo)
ls()
```

```{r}
two
```

```{r}
detach(envTwo)
# two
```


```{r}
one <- 2

changeOne <- function(a){
        one <- a
        return(one)
}
changeOne(3)
one
```


```{r}
realyChangeOne <- function(a){
        one <<- a
        return(one)
}

realyChangeOne(3)
one
```

```{r}
market <- function(rutabagas){
        money <- 0
        return(list(
                numberRutabagas = function(){
                        return(rutabagas)
                },
                revernue = function(){
                        return(money)
                },
                harvestRutabagas = function(amount){
                        rutabagas <<- rutabagas + amount
                },
                sellRutabagas = function(amount){
                        if(rutabagas >= amount){
                                rutabagas <<- rutabagas - amount
                                money <<- money + amount * 0.5
                        }else{
                                warning("We do not have that many rutabagas")
                        }
                        return(rutabagas)
                }
        ))
}

farmerJoe <- market(rutabagas = 20)
farmerJoe$numberRutabagas()
farmerJoe$revernue()
farmerJoe$harvestRutabagas(amount = 10)
farmerJoe$sellRutabagas(10)
```


## Chapter 8: S3 Classes  
### Defining classes and methods  
The `class` command is similar to other attribute commands, and it can be used to either set or get information about an object's class.  

**An object's class is a vector, and each item in the vector is the name of a class. The first element in the class vector is the object's base class, and it inherits from the other classes as you read from left to right**.  

```{r}
oneDie <- list(trials = character(0))
class(oneDie) <- "Die"
```

```{r}
oneCoin <- list(trials = character(0))
class(oneCoin) <- "Coin"
```

```{r}
reset <- function(theObject){
        UseMethod(generic = "reset", object = theObject)
        print("Reset the Trials")
}

reset.default <- function(theObject){
        print("Uh oh, not sure what to do here!")
        return(theObject)
}

reset.Die <- function(theObject){
        theObject$trials <- character(0)
        print("Reset the die.")
        return(theObject)
}

reset.Coin <- function(theObject){
        theObject$trials <- character(0)
        print("Reset the coin.")
        return(theObject)
}
```



```{r}
oneDie$trials <- c("3", "4", "1")
oneDie$trials
```


```{r}
oneDie <- reset(theObject = oneDie)
oneDie
```


```{r}
oneCoin$trials <- c("H", "T", "T")
oneCoin <- reset(theObject = oneCoin)
```

```{r}
oneCoin
```
 

```{r}
v <- c(1, 2, 3)
v <- reset(theObject = v)
v
```


### Defining objects and inheritance  
define class function and inheritance.  

```{r}
GeometricTrial <- function(){
        # Create the basic data structure - a list that keeps track of a set of trials.  
        
        # Create the basic methods as part of a list to be returned.
        me = list(
                # define the history to keep track of the trials. 
                history = character(0)
        )
        # define my class identifier and return the list. 
        class(me) <- append(x = class(me), values = "GeometricTrial")
        return(me)
}
```

```{r}
Die <- function(){
        # Define the object by first calling the constructor for the base class
        me <- GeometricTrial()
        
        # Add the class name to the end of the list of class names
        class(me) <- append(x = class(me), values = "Die")
        return(me)
}

Die()
```

```{r}
Coin <- function(){
        # define the object by calling the constructor for the base class
        me = GeometricTrial()
        
        # add the class name to the end of the list of cass names
        class(me) <- append(x = class(me), values = "Coin")
        return(me)
}

Coin()
```

define methods  
```{r}
simulation <- function(theObject){
        UseMethod(generic = "simulation", object = theObject)
}

simulation.default <- function(theObject){
        warning("Default simulation method called on unrecognized object.")
        return(theObject)
}

# define a method to run a simulation of a geometric trial  
simulation.GeometricTrial <- function(theObject){
        theObject <- reset(theObject) # reset the history
        repeat{
                # perform a single trial and add it to the history
                thisTrial <- singleTrial(theObject)
                theObject$history <- append(x = theObject$history, values = thisTrial$result)
                if(thisTrial$success){
                        break # the trial resulted in a success. Time to stop!
                }
        } # The trial was not a success. keep going.
        return(theObject)
}
```

```{r}
singleTrial <- function(theObject){
        UseMethod(generic = "singleTrial", object = theObject)
}

singleTrial.default <- function(theObject){
        # just generate a default success
        warning("Unrecognized object found for the singleTrial method")
        return(list(result = "1", success = TRUE))
}

singleTrial.GeometricTrial <- function(theObject){
        NextMethod(generic = "singleTrial", object = theObject)
}

singleTrial.Coin <- function(theObject){
        # perform a single coin flip
        value <- as.integer(
                cut(as.integer(1 + trunc(runif(1, 0, 2))),  # cut numeric to factor
                    breaks = c(0, 1, 2), 
                    labels = c("H", "T")) # label the result level, two levels 1 for H, 2 for T
        )
        return(list(result = value, success = (value == 1)))
}

singleTrial.Die <- function(theObject){
        # perform a single die roll
        value <- as.integer(1 + trunc(runif(1, 0, 6)))
        return(list(result = value, success = (value == 1)))
}
```

```{r}
coin <- Coin() # create instance
coin <- simulation(coin) # generic function performed on the instance
coin
```

```{r}
aDie <- Die()
aDie <- simulation(aDie)
aDie
```


### Encapsulation  
```{r}
getHistory <- function(theObject){
        UseMethod(generic = "getHistory", object = theObject)
}

getHistory.default <- function(theObject){
        return(factor()) # just return an empty vector of factors
}

getHistory.GeometricTrial <- function(theObject){
        return(as.factor(theObject$history))
}

getHistory.Coin <- function(theObject){
        return(as.factor(theObject$history))
}

getHistory.Die <- function(theObject){
        return(as.factor(theObject$history))
}
```

```{r}
getHistory(coin)
```

```{r}
getHistory(aDie)
```


define two new plot function  
```{r}
plot.Die <- function(theDie, theTitle){
        plot(getHistory(theDie), 
             xlab = "Value after a Die roll", 
             ylab = "Frequency",
             main = theTitle)
}

plot.Coin <- function(theCoin, theTitle){
        plot(getHistory(theCoin),
             xlab = "Value after A coin Flip", 
             ylab = "Frequency",
             main = theTitle)
}
```

```{r}
plot(theCoin = coin, theTitle = "This Here Trial")
```


```{r}
plot(aDie, "A more better Trial")
```
 

## Chapter 9: S4 Classes  
### Defining an S4 class  
define the base Ant class
```{r}
Ant <- setClass(Class = "Ant", 
                slots = c(Len = "numeric",             # the length (size) of this ant
                          Position = "numeric",        # the position of this ant (a 3 vector)
                          pA = "numeric",              # Probability that an ant will transition from inactive to active
                          pI = "numeric",              # Probability that an ant will transition from inactive to active.
                          ActivityLevel = "numeric"),  # The ant's current activity level.
                
                # set the default values for the slots (optional). 
                prototype = list(
                        Len = 4.0,
                        Position = c(0.0, 0.0, 0.0),
                        pA = 0.05,
                        pI = 0.1,
                        ActivityLevel = 0.5
                ),
                
                # Make a function that can test to see if the data is consistent.
                validity = function(object){
                        # check to see if the activity level and length is non-negative.
                        if(object@ActivityLevel < 0.0){
                                return("Error: The activity level is negative")
                        }else if(object@Len < 0.0){
                                return("Error: The length is negative")
                        }
                        return(TRUE)
                })
```

Create an Ant object:  

- using `new` command  
- using `Ant` generator  

```{r}
ant1 <- new(Class = "Ant")
ant1
```


```{r}
ant2 <- new(Class = 'Ant', Len = 4.5)
ant2
```

```{r}
ant3 <- Ant(Position = c(3, 2, 1), Len = 5.0)
ant3
```


```{r}
getClass(ant3)
```

```{r}
slotNames(ant3)
```

```{r, eval=FALSE}
ant4 <- Ant(Len = -1, Position = c(3, 2, 1)) # pass an invalid value cause an error
```


```{r}
adomAnt <- Ant(Len = 5, Position = c(3, 2, 1))
adomAnt@Len
```

```{r}
adomAnt@Position
```

modify the value in place do not triger the validity function  
```{r}
adomAnt@ActivityLevel <- -5.0
adomAnt@ActivityLevel
```


### Defining methods for S4 class  
#### Defining new methods  
```{r}
setGeneric(name = "GetLength", 
           def = function(antie){
                   standardGeneric(f = "GetLength")
           })

setMethod(f = "GetLength", 
          signature = "Ant", 
          definition = function(antie){
                  return(antie@Len)
          })
```

```{r}
ant2 <- new(Class = "Ant", Len = 4.5)
GetLength(ant2)
```

```{r}
setGeneric(name = "SetLength", 
           def = function(antie, NewLength){
                   standardGeneric(f = "SetLength")
           })

setMethod(f = "SetLength", 
          signature = "Ant", 
          definition = function(antie, NewLength){
                  if(NewLength > 0){
                          antie@Len <- NewLength
                  }else{
                          warning("Error: invalid length passed")
                  }
                  return(antie)
          })
```


```{r}
ant2 <- new(Class = "Ant", Len = 4.5)
ant2@Len
```

```{r}
ant2 <- SetLength(antie = ant2, NewLength = 6.25)
ant2@Len
```


#### Polymorphism  
The definition of S4 classes allows methods to be overloaded. That is, multiple functions that have the same name can be defined, and the function that is executed is determined by the arguments' types.  

Two or more functions can have the same name, but the types of the arguments passed to them differ. There are two methods to set the activity level. One takes a floating point number and sets the activity level based to the value passed to it. The other takes a logical value and sets the activity level to zero if the argument is FALSE; otherwise, it sets it to a default value.  

The idea is to use the `signature` option in the `setMethod` command. It is set to a vector of class names, and **the order of the class names is used to determine which function should be called for a given set of arguments**.  

An important thing to note, though, is that **the prototype defined in the `setGeneric` command defines the names of the arguments, and the argument names in both methods must be exactly the same and in the same order**.  

```{r}
setGeneric(name = "SetActivityLevel", 
           def = function(antie, activity){
                   standardGeneric(f = "SetActivityLevel")
           })

setMethod(f = "SetActivityLevel", 
          signature = c("Ant", "logical"), 
          definition = function(antie, activity){
                  if(activity){
                          antie@ActivityLevel = 1
                  }else{
                          antie@ActivityLevel = 0.0
                  }
                  return(antie)
          })

setMethod(f = "SetActivityLevel", 
          signature = c("Ant", "numeric"), 
          definition = function(antie, activity){
                  if(activity > 0.0){
                          antie@ActivityLevel = activity
                  }else{
                          warning("The activity level cannot be negative")
                  }
                  return(antie)
          })
```

Once the two methods are defined, R will use the class names of the arguments to determine which function to call in a given context.  
```{r}
ant2 <- SetActivityLevel(antie = ant2, activity = 0.1)
ant2
```

```{r}
ant2 <- SetActivityLevel(antie = ant2, activity = F)
ant2
```

Once the two methods are defined, R will use the class names of the arguments to determine which function to call in a given context.  

There are two more additional data types recognized by the `signature` option: `ANY` and `missing`. These can be used to match any data type or a missing value.  

The `…` argument must be the last argument and is used to indicate that any remaining parameters are passed as they appear in the original call to the function. Ellipses can make the use of the overloaded functions in a more flexible way than indicated. `help(dotsMethods)` for more information.  


#### Extending the existing methods  
```{r}
Coordinate <- setClass(Class = "Coordinate", 
                       slots = c(
                               x = "numeric", 
                               y = "numeric"
                       ), 
                       prototype = list(
                               x = 0.0, 
                               y = 0.0
                       ), 
                       # check if the coordinate is outside of a circle of radius 100
                       validity = function(object){
                               print("Checking the validity of the point ...")
                               Sys.sleep(2)
                               if(object@x*object@x + object@y * object@y > 100.0 * 100.0){
                                       return(paste("Error: the point is too far away from the origin."))
                               }else{
                                       print("Validity is confirmed!")
                               }
                               return(TRUE)
                       })

setGeneric(name = "SetPoint", 
           def = function(Coord, x, y){
                   standardGeneric(f = "SetPoint")
           })

setMethod(f = "SetPoint", 
          signature = "Coordinate", 
          definition = function(Coord, x, y){
                  print("Setting the point")
                  Coord@x = x
                  Coord@y = y
                  return(Coord)
          })
```

extend the show already exist method  
show: display the object, by printing, plotting or whatever suits its class.  
```{r}
setMethod(f = "show", 
          signature = "Coordinate", 
          definition = function(object){
                  cat("The coordinate is X: ", object@x, " Y: ", object@y, "\n")
          })
```


```{r}
point <- Coordinate(x = 1, y = 5)
print(point)
```

```{r}
point
```

```{r}
point <- SetPoint(point, x = 10, y = 10)
point
```

```{r}
setMethod(f = "initialize", 
          signature = "Coordinate", 
          def = function(.Object, x = 0.0, y = 0.0){
                  print("Checking the point")
                  .Object = SetPoint(.Object, x, y)
                  validObject(.Object)
                  return(.Object)
          })
```


```{r}
point <- Coordinate(x = 2, y = 3)
```

```{r}
point
```


#### Inheritance 
When a new class is created, it can inherit from an existing class by setting the `contains` parameter. **This can be set to a vector of classes for multiple inheritance**.  

To make an class as an `VIRTUAL` class just add the `VRUTUAL` character string in the `contains` parameter.  

define the female ant class  
```{r}
FemaleAnt <- setClass(Class = "FemaleAnt", 
                      slots = c(Food = "numeric"),
                      prototype = list(Food = 0), 
                      validity = function(object){
                              print("Validity: FemaleAnt")
                              if(object@Food < 0){
                                      return("Error: The number of food units is negative")
                              }
                              return(TRUE)
                      },
                      contains = c("Ant", "VIRTUAL"))


WorkerAnt <- setClass(Class = "WorkerAnt", 
                      slots = c(
                              Foraging = "logical",
                              Alarm = "logical"
                      ), 
                      prototype = list(
                              Foraging = FALSE,
                              Alarm = FALSE
                      ), 
                      validity = function(object){
                              print("Validity: WorkerAnt")
                              if(!(is.logical(object@Foraging) & is.logical(object@Alarm))){
                                      warning("One or Both of Foraging and Alarm is not logical")
                              }
                              return(TRUE)
                      }, 
                      contains = c("FemaleAnt"))
```


```{r}
worker <- WorkerAnt(Position = c(-1, 3, 5), Len = 2.5)
worker
```

```{r}
worker <- SetLength(worker, 3.5)
```

```{r}
GetLength(worker)
```

The `callNextMethod` command is used to request that R searches for and executes a method of the same name that is a member of a parent class.  
```{r}
setMethod(f = "initialize", 
          def = function(.Object, Len = 4, Position = c(0, 0, 0)){
                  print("Ant initialize")
                  .Object = SetLength(.Object, Length)
                  .Object = SetPosition(.Object, Position)
                  validObject(.Object)
                  return(.Object)
          })
```

```{r}
setMethod(f = "initialize", 
          signature = "WorkerAnt", 
          def = function(.Object, Len = 4, Position = c(0, 0, 0)){
                  print("WorkerAnt initialize")
                  .Object <- callNextMethod(.Object, Len, Position)
                  .Object = SetLength(.Object, Length)
                  .Object = SetPoint(.Object, Position)
                  validObject(.Object)
                  return(.Object)
          })
```

```{r}
worker <- WorkerAnt(Position = c(-1, 3, 5), Len = 2.5)
```


Four usefull command:  

- `slotNames`: pass an instance of an class to the function.     
- `getSlots`: pass an class to the function.  
- `getClass`: can ba instance class or class itself.  
- `slot`: pass an instance of an class and an slot name while retrive the content of the slot.  


## Chapter 10: Case Study  
### The Course class  
```{r}
Course <- setClass(Class = "Course", 
                   slots = c(
                           GradesFile = "character", 
                           GradeTypes = "character", 
                           Grades = "list"
                   ), 
                   prototype = list(
                           GradesFile = "", 
                           GradeTypes = c("test", "hw", "quiz", "project"),
                           Grades = list()
                   ), 
                   validity = function(object){
                           return(TRUE)
                   })
```

define the methods used to retrieve or set the values within a Course object.  
```{r}
setGeneric(name = "GetFileName", 
           def = function(course){
                   standardGeneric(f = "GetFileName")
           })

setMethod(f = "GetFileName", 
          signature = "Course", 
          definition = function(course){
                  return(course@GradesFile)
          })

setGeneric(name = "SetFileName", 
           def = function(course, filename){
                   standardGeneric(f = "SetFileName")
           })

setMethod(f = "SetFileName", 
          signature = "Course", 
          definition = function(course, filename){
                  course@GradesFile <- filename
                  return(course)
          })
```

```{r}
setGeneric(name = "GetGrades", 
           def = function(course){
                   standardGeneric(f = "GetGrades")
           })

setMethod(f = "GetGrades", 
          signature = "Course", 
          definition = function(course){
                  return(course@Grades)
          })

setGeneric(name = "SetGrades", 
           def = function(course, grades){
                   standardGeneric(f = "SetGrades")
           })

setMethod(f = "SetGrades", 
          signature = "Course", 
          definition = function(course, grades){
                  course@Grades = grades
                  return(course)
          })
```

```{r}
setGeneric(name = "GetGradeTypes", 
           def = function(course){
                   standardGeneric(f = "GetGradeTypes")
           })

setMethod(f = "GetGradeTypes", 
          signature = "Course", 
          definition = function(course){
                  return(course@GradeTypes)
          })

setGeneric(name = "SetGradeTypes", 
           def = function(course, gradetypes){
                   standardGeneric(f = "SetGradeTypes")
           })

setMethod(f = "SetGradeTypes", 
          signature = "Course", 
          definition = function(course, gradetypes){
                  course@GradeTypes = gradetypes
                  return(course)
          })
```

```{r}
setGeneric(name = "ReadGrades", 
           def = function(course){
                   standardGeneric(f = "ReadGrades")
           })

setMethod(f = "ReadGrades", 
          signature = "Course", 
          definition = function(course){
                  grades <- read.csv(GetFileName(course))
                  convertedGrade <- list()
                  courseTypes <- GetGradeTypes(course)
                  for(gradeItem in names(grades)){ # names(data.frame) == colnames(data.frame)
                          for(type in courseTypes){
                                  if(length(grep(type, gradeItem)) > 0){
                                          if((class(grades[[gradeItem]]) == "numeric") || (class(grades[[gradeItem]]) == "integer")){
                                                  thisItem <- NumericGrade()
                                          }else{
                                                  thisItem <- LetterGrade()
                                          }
                                  }
                                  thisItem <- SetValue(thisItem, grades[[gradeItem]])
                                  convertedGrade[gradeItem] <- thisItem
                          }
                  }
                  return(setGrades(course, convertedGrade))
          })
```


### The assignment classes  
```{r}
Assignment <- setClass(Class = "Assignment", 
                       slots = c(
                               Name = "character", 
                               Number = "numeric"
                       ), 
                       prototype = list(
                               Name = "Test", 
                               Number = as.integer(1)
                       ), 
                       validity = function(object){
                               if(object@Number < 0){
                                       object@Number <- 0
                                       warning("A negative number for the assignment", 
                                               "number is passed. It is set to zero.")
                               }
                               return(TRUE)
                       })
```
The primary purpose of the Assignment class is to act as the base class for other types of assignments.  

```{r}
setGeneric(name = "GetName", 
           def = function(assignment){
                   standardGeneric(f = "GetName")
           })

setMethod(f = "GetName", 
          signature = "Assignment", 
          definition = function(assignment){
                  return(assignment@Name)
          })
```


### The NumericGrade class  
```{r}
NumericGrade <- setClass(Class = "NumericGrade", 
                         slots = c(
                                 Value = "numeric"
                         ), 
                         prototype = list(
                                 Value = 0.0
                         ), 
                         validity = function(object){
                                 if(object@Value < 0){
                                         object@Value <- 0
                                         warning(paste("A negative number for the assignment value\n is passed. It is set to zero."))
                                 }
                                 return(TRUE)
                         }, 
                         contains = "Assignment")
```


methods for this class  
```{r}
setGeneric(name = "GetValue", 
           def = function(assignment){
                   standardGeneric(f = "GetValue")
           })

setMethod(f = "GetValue", 
          signature = "NumericGrade", 
          definition = function(assignment){
                  return(assignment@Value)
          })

setGeneric(name = "SetValue", 
           def = function(assignment, value){
                   standardGeneric(f = "SetValue")
           })

setMethod(f = "SetValue", 
          signature = "NumericGrade", 
          definition = function(assignment, value){
                  assignment@Value = value
                  return(assignment)
          })
```


```{r}
setGeneric(name = "GradeReport", 
           def = function(assignment, maxGrade = NA, div = 10){
                   standardGeneric(f = "GradeReport")
           })

setMethod(f = "GradeReport", 
          signature = "Assignment", 
          definition = function(assignment, maxGrade = NA, div = 10){
                  print(noquote(paste("Grade report for", GetName(assignment))))
                  print(noquote(""))
                  print(summary(assignment))
                  values <- GetValue(assignment)
                  if(is.na(maxGrade)){
                          maxGrade <- max(values)
                          warning(paste("The max grade is not set, and it is assumed to be ", maxGrade))
                  }
                  skip <- maxGrade * div / 100
                  while(maxGrade <= max(values)){
                          maxGrade <- maxGrade + skip
                  }
                  numLower <- ceiling((maxGrade - min(values))/ skip)
                  bins <- c(seq(maxGrade - numLower*skip), max(c(values, maxGrade)), by = skip)
                  levs <- cut(values, breaks = bins, right = FALSE)
                  gradeFreqs <- table(levs)
                          print(noquote(''))
                          print(noquote("Stem leaf plot of grades: "))
                          print(stem(values))
                          print(noquote(''))
                          
                          print(noquote("Grade Frequencies: "))
                          print(gradeFreqs)
                          print(noquote(""))
                          
                          print(noquote("Sorted Grades: "))
                          print(sort(values))
          })
```


### The LetterGrade class  
```{r}
LetterGrade <- setClass(Class = "LetterGrade", 
                        slots = c(
                                Value = "character", 
                                Scale = "list"
                        ), 
                        prototype = list(
                                Value = "F",
                                Scale = list(
                                        "A+" = 98, "A" = 95, "A-" = 92, 
                                        "B+" = 88, "B" = 85, "B-" = 83,
                                        "C+" = 78, "C" = 75, "C-" = 73,
                                        "D+" = 68, "D" = 65, "D-" = 63,
                                        "F+" = 58, "F" = 55, "F-" = 53, 
                                        "NA" = 0
                                )
                        ), 
                        validity = function(object){
                                pos <- grep(paste(object@Value, "$", sep = ""), names(object@Scale))
                                if(length(pos) != 1){
                                        object@Value <- "F-"
                                        warning("The garde is not recognized.")
                                }
                                return(TRUE)
                        },
                        contains = "Assignment")
```

```{r}
setGeneric(name = "GetScale", 
           def = function(lettergrade){
                   standardGeneric(f = "GetScale")
           })

setMethod(f = "GetScale", 
          signature = "Assignment", 
          definition = function(lettergrade){
                  return(lettergrade@Scale)
          })
```

```{r}
setMethod(f = "SetValue", 
          signature = "LetterGrade", 
          definition = function(assignment, value){
                  lupe <- 1
                  value <- as.character(value)
                  theScale <- GetScale(assignment)
                  theNames <- name(theScale)
                  while(lupe <= length(value)){
                          thePattern <- paste("^", sub("\\+", "\\\\+", value[lupe]), "$", sep = "")
                          pos <- grep(thePattern, theName)
                          if(value[lupe] == ''){
                                  value[lupe] <- "NA"
                          }else if(length(pos) != 1){
                                  warning(paste("The grade \"", value[lupe], "\" is not recognized. It is set to NA."))
                                  value[lupe] <- "NA"
                          }
                          lupe <- lupe + 1
                  }
                  assignment@Value <- value
                  return(assignment)
          })
```

```{r}
setMethod(f = "GradeReport", 
          signature = "LetterGrade", 
          definition = function(assignment, maxGrade = NA, div = 10){
                  print(noquote(""))
                  print(noquote(paste("Grade report for", GetName(assignment))))
                  print(noquote(""))
                  print(summary(assignment))
          })
```


### reading grades from a file  
```{r}
course <- Course()
course <- SetGradeTypes(course, gradetypes = c("test", "hw", "quiz", "project", "final"))
course <- SetFileName(course, "shortList.csv")
course <- ReadGrades(course)
```





## Chapter 11: Case Study - Simulation  





























